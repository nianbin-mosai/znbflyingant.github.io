<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[生产者消费者问题]]></title>
    <url>%2F2017%2F05%2F12%2F%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314package 生产者消费者;public class ProducerConsumerTest &#123; public static void main(String[] args) &#123; PublicResource resource = new PublicResource(); new Thread(new ProducerThread(resource)).start(); new Thread(new ConsumerThread(resource)).start(); new Thread(new ProducerThread(resource)).start(); new Thread(new ConsumerThread(resource)).start(); new Thread(new ProducerThread(resource)).start(); new Thread(new ConsumerThread(resource)).start(); &#125;&#125; 123456789101112131415161718192021222324252627282930package 生产者消费者;/** * 生产者线程，负责生产公共资源 * @author dream * */public class ProducerThread implements Runnable&#123; private PublicResource resource; public ProducerThread(PublicResource resource) &#123; this.resource = resource; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; resource.increase(); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233package 生产者消费者;/** * 消费者线程，负责消费公共资源 * @author dream * */public class ConsumerThread implements Runnable&#123; private PublicResource resource; public ConsumerThread(PublicResource resource) &#123; this.resource = resource; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; resource.decrease(); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package 生产者消费者;/** * 公共资源类 * @author dream * */public class PublicResource &#123; private int number = 0; private int size = 10; /** * 增加公共资源 */ public synchronized void increase() &#123; while (number &gt;= size) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; number++; System.out.println(&quot;生产了1个，总共有&quot; + number); notifyAll(); &#125; /** * 减少公共资源 */ public synchronized void decrease() &#123; while (number &lt;= 0) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; number--; System.out.println(&quot;消费了1个，总共有&quot; + number); notifyAll(); &#125;&#125;]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>JavaConcurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发基础知识]]></title>
    <url>%2F2017%2F05%2F12%2FJava%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[（Executor框架和多线程基础） Thread与Runable如何实现多线程 Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 实现Runnable接口相比继承Thread类有如下优势： 可以避免由于Java的单继承特性而带来的局限 增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的 适合多个相同程序代码的线程区处理同一资源的情况 补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536class MyTask implements Callable&lt;Integer&gt; &#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125; &#125; public class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integer&gt; future : list) &#123; while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125; &#125; 线程同步的方法有什么；锁，synchronized块，信号量等 锁的等级：方法锁、对象锁、类锁 生产者消费者模式的几种实现，阻塞队列实现，sync关键字实现，lock实现,reentrantLock等 ThreadLocal的设计理念与作用，ThreadPool用法与优势（这里在Android SDK原生的AsyncTask底层也有使用） 线程池的底层实现和工作原理（建议写一个雏形简版源码实现） 几个重要的线程api，interrupt，wait，sleep，stop等等 写出生产者消费者模式。 ThreadPool用法与优势。 Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。 wait()和sleep()的区别。 sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用sleep 不会释放对象锁。wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。 ###3、IO（IO,NIO，目前okio已经被集成Android包） IO框架主要用到什么设计模式 JDK的I/O包中就主要使用到了两种设计模式：Adatper模式和Decorator模式。 NIO包有哪些结构？分别起到的作用？ NIO针对什么情景会比IO有更好的优化？ OKIO底层实现]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>JavaConcurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment---监听返回键事件]]></title>
    <url>%2F2017%2F05%2F10%2FFragment_%E7%9B%91%E5%90%AC%E8%BF%94%E5%9B%9E%E9%94%AE%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候为了方便代码维护，在fragment中可能要处理一些监听fragment back键12345678910111213141516//主界面获取焦点 private void getFocus() &#123; getView().setFocusableInTouchMode(true); getView().requestFocus(); getView().setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (event.getAction() == KeyEvent.ACTION_UP &amp;&amp; keyCode == KeyEvent.KEYCODE_BACK) &#123; // 监听到返回按钮点击事件 ...... return true; &#125; return false; &#125; &#125;); &#125; 以上代码是stackoverflow.com中找到的一个解决方案，但是在使用时，由于Fragment页面里可能有其他能获取焦点的View（例如EditText），会导致监听失效，点击返回键会返回到上个页面。 更完善的解决方案：除了上面的代码，我们需要对可以获取焦点的View的setOnKeyListener进行处理，这里以一个EditText为例： 12345678910111213141516//private EditText nickname;nickname.setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_UP) &#123; //关闭软键盘 InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(nickname.getWindowToken(), 0); //使得根View重新获取焦点，以监听返回键 getFocus(); &#125; return false; &#125; &#125;); 使用到的资料： http://blog.csdn.net/ccpat/article/details/45176665http://stackoverflow.com/questions/22552958/handling-back-press-when-using-fragments-in-android]]></content>
      <categories>
        <category>事件监听</category>
      </categories>
      <tags>
        <tag>事件传递管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化-内存泄漏的8个Case]]></title>
    <url>%2F2016%2F05%2F10%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[1.什么是内存泄漏？JVM内存管理 关于内存泄漏我们要知道，JVM内存分配的几种策略。 1.静态的 静态的存储区，内存在程序编译的时候就已经分配好了，这块内存在程序整个运行期间都一直存在，它主要存放静态数据、全局的static数据和一些常量。 2.栈式的 在执行方法时，方法一些内部变量的存储都可以放在栈上面创建，方法执行结束的时候这些存储单元就会自动被注释掉。栈 内存包括分配的运算速度很快，因为内在在处理器里面。当然容量有限，并且栈式一块连续的内存区域，大小是由操作系统决定的，他先进后 出，进出完成不会产生碎片，运行效率高且稳定 3.堆式的 也叫动态内存 。我们通常使用new 来申请分配一个内存。这里也是我们讨论内存泄漏优化的关键存储区。GC会根据内存的使用情况，对堆内存里的垃圾内存进行回收。 堆内存是一块不连续的内存区域，如果频繁地new/remove会造成大量的内存碎片，GC频繁的回收，导致内存抖动，这也会消耗我们应用的性能我们知道可以调用 System.gc();进行内存回收，但是GC不一定会执行。 面对GC的机制，我们是否无能为力？其实我们可以通过声明一些引用标记来让GC更好对内存进行回收。 类型 回收时机 生命周期 StrongReference （强引用） 任何时候GC是不能回收他的，哪怕内存不足时，系统会直接抛出异常OutOfMemoryError，也不会去回收 进程终止 SoftReference （软引用） 当内存足够时不会回收这种引用类型的对象，只有当内存不够用时才会回收 内存不足，进行GC的时候 WeakReference （弱引用） GC一运行就会把给回收了 GC后终止 PhantomReference (虚引用) 如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收 任何时候都有可能 开发时，为了防止内存溢出，处理一些比较占用内存并且生命周期长的对象时，可以尽量使用软引用和弱引用。 Tip：成员变量全部存储在堆中（包括基本数据类型，引用及引用的对象实体），因为他们属于类，类对象最终还是要被new出来的。局部变量的基本数据类型和引用存在栈中，应用的对象实体存储在堆中。因为它们属于方法当中的变量，生命周期会随着方法一起结束 内存泄漏的定义当一个对象已经不需要使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用，从而导致了对象不能被GC回收。 这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏。 内存泄漏与内存溢出的区别 内存泄漏（Memory Leak） 进程中某些对象已经没有使用的价值了，但是他们却还可以直接或间接地被引用到GC Root导致无法回收。当内存泄漏过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM 内存溢出（OOM） 当 应用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出 内存泄漏带来的影响 应用卡顿 泄漏的内存影响了GC的内存分配，过多的内存泄漏会影响应用的执行效率 应用异常（OOM） 过多的内存泄漏，最终会导致 Dalvik可分配的内存越来越少，更加容易出现OOM 2.Android开发常见的内存泄漏（1）单例造成的内存泄漏 错误示例 当调用getInstance时，如果传入的context是Activity的context。 只要这个单例没有被释放，那么这个Activity也不会被释放一直到进程退出才会释放。 解决方案 能使用Application的Context就不要使用Activity的Content，Application的生命周期伴随着整个进程的周期 （2）非静态内部类创建静态实例造成的内存泄漏 错误示例 解决方案 将非静态内部类修改为静态内部类。（静态内部类不会隐式持有外部类） （3）Handler造成的内存泄漏 错误示例 mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。 解决方案 创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息 （4）线程造成的内存泄漏 错误示例 异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成， 那么将导致Activity的内存资源无法回收，造成内存泄漏 解决方案 使用 静态内部类，避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源 （5）资源未关闭造成的内存泄漏 错误示例 对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏 解决方案 在Activity销毁时及时关闭或者注销 （6）使用了静态的Activity和View 错误示例 解决方案 应该及时将静态的应用 置为null，而且一般不建议将View及Activity设置为静态 （7）注册了系统的服务，但onDestory未注销 错误示例 解决方案//不需要用的时候记得移除监听sensorManager.unregisterListener(listener); （8）不需要用的监听未移除会发生内存泄露 错误示例 解决方案 Tip：tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
</search>